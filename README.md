# Gelap â€” Private Shielded DEX with SP1 zkVM

Gelap is a shielded pool and private transaction system leveraging the **SP1 zkVM**. This document outlines the integration details for the SP1 prover and verifier, specifically for developers working on the off-chain prover and on-chain verification logic.

## Overview

The Gelap smart contract (`GelapShieldedAccount.sol`) acts as a verifier for private state transitions. It relies on the SP1 zkVM to perform heavy computations off-chain, including:
- Merkle inclusion proof verification.
- Pedersen commitment verification.
- Nullifier generation and validation.
- New Merkle root computation.

The contract receives two main artifacts from the prover:
1.  **`publicValues`**: ABI-encoded struct containing the state changes (new root, nullifiers, commitments).
2.  **`proofBytes`**: The opaque ZK proof generated by SP1.

The contract calls `ISP1Verifier.verifyProof(programVKey, publicValues, proofBytes)` to validate the transition.

> **Note**: Unlike some Succinct examples, Gelap **does NOT** use `a`, `b`, or `n` (Fibonacci inputs). Only `publicValues` and `proofBytes` are required.

## Smart Contract Integration

### Verifier Interface
The contract expects the prover to submit a proof that validates against a specific `programVKey`.

```solidity
function transact(bytes calldata publicInputs, bytes calldata proofBytes) external;
function withdraw(bytes calldata publicInputs, bytes calldata proofBytes, address receiver) external;
```

### Public Values Purpose
The `publicValues` field is critical. It is a structured data blob computed by the prover inside the zkVM. It contains the **final output state** that the smart contract must apply.

## ABI Structs

The prover **MUST** encode the public values using standard Solidity ABI encoding (`abi.encode(...)`). The field order and types must match exactly.

### 1. PublicInputsStruct (for `transact`)

Used for internal private transfers.

```solidity
struct PublicInputsStruct {
    bytes32 newRoot;              // Merkle root final after private tx
    bytes32[] nullifiers;         // Nullifiers marking spent notes
    bytes32[] newCommitments;     // New commitments (output notes)
}
```

**Encoding Rule**: `abi.encode(PublicInputsStruct)`

### 2. WithdrawPublicInputsStruct (for `withdraw`)

Used for withdrawing funds from the shielded pool to a public address.

```solidity
struct WithdrawPublicInputsStruct {
    bytes32 newRoot;              // Merkle root after withdrawal
    bytes32[] nullifiers;         // Nullifiers spent
    address token;                // ERC20 token address
    uint256 amount;               // Amount to withdraw
    address receiver;             // Public EOA address receiving funds
    bytes32[] newCommitments;     // Optional: change outputs
}
```

**Encoding Rule**: `abi.encode(WithdrawPublicInputsStruct)`

> **Important**: The `receiver` inside the struct MUST match the `receiver` argument passed to the `withdraw()` function on-chain. This prevents front-running/redirection attacks.

## Prover Responsibilities

The SP1 program (Guest) is responsible for the following:

1.  **Merkle Proofs**: Verify inclusion of spent notes in the current tree.
2.  **Nullifiers**: Compute and verify nullifiers to prevent double-spending.
3.  **Commitments**: Compute Pedersen commitments for new notes.
4.  **Root Update**: Construct the new Merkle root.
    *   **Hash Function**: `keccak256`
    *   **Zero Hashes**: Must match contract's `zeroHashes`.
    *   **Depth**: 32
5.  **ABI Encoding**: Encode the output struct using EVM ABI encoder **EXACTLY**.
6.  **Output**: Return `vkey`, `publicValues`, and `proof`.

## Output JSON Format

After generating the proof, the prover service/script should output JSON in the following format:

```json
{
  "vkey": "0x...",
  "publicValues": "0x...", 
  "proof": "0x..."
}
```

*   `publicValues`: The hex string of the ABI-encoded struct.
*   `proof`: The hex string of the opaque SP1 proof.

## Merkle Tree Requirements

To ensure the `newRoot` computed in SP1 matches the contract's expectation:

*   **Hash Function**: `keccak256` (Solidity compatible).
*   **Tree Depth**: 32 levels.
*   **Indexing**: `nodeIndex = (level << 32) | index`.
*   **Zero Hashes**: The SP1 program must use the exact same zero-hash values as the contract's `_initZeroHashes()` function.

## Events

Indexers and wallets should listen to these events to track state:

*   `AccountUpdated(bytes32 commitment, bytes encryptedMemo)`: New note created.
*   `TransactionExecuted(bytes32 newRoot, bytes32[] nullifiers, bytes32[] newCommitments)`: Private transaction completed.
*   `WithdrawExecuted(address receiver, address token, uint256 amount)`: Public withdrawal completed.

## Integration Checklist

- [ ] **ABI Encoding**: Is the output encoded using standard Solidity ABI rules?
- [ ] **Field Order**: Do the struct fields in Rust/SP1 match the Solidity struct order exactly?
- [ ] **Merkle Root**: Does the SP1 `newRoot` calculation match the contract's `keccak256` logic?
- [ ] **Nullifiers**: Are nullifiers correctly derived and unique?
- [ ] **Verification Key**: Does the proof correspond to the `vKey` deployed on the contract?
